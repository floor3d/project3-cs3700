#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy

class Router:

    relations = {} #our relationships. IP : [cust/peer/prov]
    sockets = {} #our listening UDP connections. IP : socket
    ports = {} #the port of the neighbor. IP : port
    route_announcements = []
    forwarding_table = [] #needs network netmask localpref selfOrigin ASPath origin
    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor),
                "dst": neighbor, "msg": {}  }))


    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        for key in self.relations:
            if key == network:
                self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))
                return
        network = self.findProperNetwork(network)
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))


    
    #figures out what kind of message it is and passes it on to the proper handler
    def handleMessage(self, msg):
        obj = json.loads(msg)
        msg_type = obj['type']
        if(msg_type == "update"):
            self.handleUpdate(obj)
        elif(msg_type == "data"):
            self.handleData(obj)
        elif(msg_type == "dump"):
            self.handleDump(obj)
        return


    #handles update message: copy announcement, add entry to forwarding table, send copy of announcement 
    #TODO: change so that we do not assume that all neighboring routers are customers and 
    # all network prefixes are disjoint (simplified forwarding table)
    def handleUpdate(self, msg):
        self.route_announcements.append(msg) 
        addr = self.forwarding_table_address(msg['msg']['network'], msg['msg']['netmask'])  
        if addr != -1:
            # we must update the routing table entry with this new data
            return
        else:
            obj = msg['msg']
            obj['src'] = msg['src']
            self.forwarding_table.append(copy.deepcopy(obj))
        for item in range(len(self.forwarding_table)):
            if "src" in self.forwarding_table[item]:
                self.forwarding_table[item]["peer"] = self.forwarding_table[item].pop("src")
        if(self.relations[msg['src']] == "cust"):
            obj = {}
            obj["type"] = "update"
            obj["msg"] = {
                    "network": msg['msg']['network'],
                    "netmask": msg['msg']['netmask'],
                    "ASPath": msg['msg']['ASPath']
                    }
            obj['msg']['ASPath'].insert(0, self.asn) #add own asn to list
            for neighbor in self.relations:
                obj['src']= self.our_addr(neighbor)
                obj['dst'] = neighbor
                if obj['dst'] != msg['src']:
                    self.send(obj['dst'], json.dumps(obj))
                    #only send updates to customers
            return

    # return index of matching fw table
    def forwarding_table_address(self, network, netmask):
        return -1


    # handles data message. TODO: do not assume that all data messages will be valid and legal
    def handleData(self, msg):
        obj = {}
        obj['src'] = self.our_addr(msg['src'])
        obj['dst'] = msg['dst']
        neighbor = self.findProperNetwork(msg['dst'])
        if(neighbor is None):
            #we can't find the route for this one. Send back with "no route" message.
            obj['type'] = "no route"
            obj['msg'] = {}
            self.send(obj['dst'], json.dumps(obj))
        else:
            #obj['dst'] = neighbor
            obj['type'] = "data"
            obj['msg'] = msg['msg']
            self.send(neighbor, json.dumps(obj))
        
    #finds correct network to route to via forwarding table. returns None if not found.
    def findProperNetwork(self, ip):
        possibleRets = []
        orig = ip.split(".")
        for i in range(len(orig)):
            orig[i] = bin(int(orig[i])).replace("0b","")
            orig[i] = orig[i].zfill(8)
        ip = ''.join(orig)
        for entry in self.forwarding_table:
            other = entry['network'].split(".")
            netmask_arr = entry['netmask'].split(".")
            for i in range(len(other)):
                other[i] = bin(int(other[i])).replace("0b","")
                other[i] = other[i].zfill(8)
            for i in range(len(netmask_arr)):
                netmask_arr[i] = bin(int(netmask_arr[i])).replace("0b","")
                netmask_arr[i] = netmask_arr[i].zfill(8)
            ip2 = ''.join(other)
            netmask2 = ''.join(netmask_arr)
            if ip == ip2:
                return entry
            for i in range(len(netmask2)):
                if netmask2[i] == '0' and ip[i-1] == ip2[i-1]:
                    possibleRets.append((entry, i))
                    break
                elif ip[i] != ip2[i]:
                    break
        if(len(possibleRets) == 0):
            return None
        elif len(possibleRets) == 1:
            return possibleRets[0][0]['peer']
        return self.findBestFittingNetwork(possibleRets)['peer']



    #finds the most specific / best fitting route for multiple possibilities.
    #possibleRets = listof [  (route_table_row, netmask_length)  ]
    #TODO this
    def findBestFittingNetwork(self, possibleRets):
        winner = possibleRets[0]
        for i in range(len(possibleRets)):
            contender = possibleRets[i]
            if(contender[1] > winner[1]):
                winner = contender
            elif(contender[0]['localpref'] > winner[0]['localpref']):
                winner = contender
            elif(contender[0]['selfOrigin'] and not winner[0]['selfOrigin']):
                winner = contender
            elif(len(contender[0]['ASPath']) < len(winner[0]['ASPath'])):
                winner = contender
            elif(self.hasBetterOrigin(contender[0]['origin'], winner[0]['origin'])):
                winner = contender
            elif(self.ipAddressLower(contender[0]['peer'], winner[0]['peer'])):
                winner = contender
        return winner[0]
    

    #is origin 1 better than origin 2?
    def hasBetterOrigin(self, one, two):
        if one == 'IGP' and two != 'IGP':
            return True
        if one == 'EGP' and two == 'UNK':
            return True
        return False

    

    #is ip 1 address lower than ip 2 address?
    def ipAddressLower(self, one, two):
        num1 = int(one.replace(".",""))
        num2 = int(two.replace(".",""))
        return num1 < num2

        
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.handleMessage(msg)
                print("Received message '%s' from %s" % (msg, srcif))
        return


    #sends table message to sender of dump message
    def handleDump(self, msg):
        toSend = {}
        toSend['src'] = msg['dst']
        toSend['dst'] = msg['src']
        toSend['type'] = "table"
        toSend['msg'] = self.forwarding_table
        self.send(toSend['dst'], json.dumps(toSend))
        return

    

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
